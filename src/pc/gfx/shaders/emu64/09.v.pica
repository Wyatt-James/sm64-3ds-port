; position, normals + alpha

; ----- Uniforms -----
.fvec rsp_color_selection ; Enum { col1_rgb, col1_alpha, col2_rgb, col2_alpha }

; ----- Constant Uniforms -----
.fvec emu64_const_1       ; {   0,   1, 1/127,  1/255 }

; At least one const must be present in each DVLE thanks to a libctru (or c3d?) bug.
.constf dummy_const (0.0, 0.0, 0.0, 0.0)

; ----- Aliases -----
.alias zeros       emu64_const_1.xxxx ; Vector full of zeros

; ----- Subroutine Registers -----
; These are intended purposes, but they may vary betwen subroutines.
.alias sub_scratch_1  r10 ; Subroutine scratch register
.alias sub_scratch_2  r11 ; Subroutine scratch register
.alias sub_scratch_3  r8  ; Subroutine scratch register
.alias sub_param_1    r12 ; Subroutine input register
.alias sub_param_2    r13 ; Subroutine input register
.alias sub_param_3    r14 ; Subroutine input register
.alias sub_return_1   r15 ; Subroutine return register
.alias sub_return_2   r9  ; Subroutine return register

; ----- Inputs -----
.in inpos   v0 ; xyz, plus garbage for w
.in innorm  v1 ; xyz, plus garbage for w
.in inalpha v2 ; alpha in R, scale [0,255], garbage in GBA

; ----- Outputs -----
.out outpos position  ; xyzw
.out outtc0 texcoord0 ; texture unit 0
.out outtc1 texcoord1 ; texture unit 1
.out outclr color     ; rgba

.entry main_09
.proc main_09

projection:
    mov sub_param_1, inpos
    call matrix_projection
    mov outpos, sub_return_1
    mov r0, sub_return_2     ; Pre-system projected vertex
texture:
    ; outtex = 0
    mov outtc0, zeros
    mov outtc1, zeros
color:

    mov sub_param_1, innorm
    mov sub_param_1.a, inalpha.x
    call calculate_lighting

    ; Resolve color
    mov sub_param_1, rsp_color_selection.xy  ; input CC source
    mov sub_param_2, sub_return_1            ; input vertex color
    mov sub_param_3, r0                      ; input transformed position
    call cc_color_select
    mov outclr, sub_return_1

    ; We're finished
    end
.end
