; position, 2 colors rgba

; Uniforms
.fvec projection_mtx[4], model_view_mtx[4], game_projection_mtx[4]

; Constants
.constf main_const_1(0.0, 1.0, -1.0, 0.00392156862)

.alias zeros       main_const_1.xxxx ; Vector full of zeros
.alias ones        main_const_1.yyyy ; Vector full of ones
.alias nones       main_const_1.zzzz ; Vector full of negative ones
.alias color_scale main_const_1.wwww ; Vector full of 1/255
.alias tcofs       main_const_1.xyxx ; Vector of [ tcof1, tcof2, 0, 0 ]

; Inputs
.in inpos v0 ; xyz, plus garbage for w
.in inclr v1
.in inclr2 v2

; Outputs
.out outpos position  ; xyzw
.out outtc0 texcoord0 ; texture unit 0
.out outtc1 texcoord1 ; texture unit 1
.out outclr color     ; rgba

.entry main_20
.proc main_20

setup:
    mov r0, inpos
model_view:
    ; r1 = model_view_mtx * inpos
    ; Needs to be DPHI because 1.0 is appended to src1 (left input arg).
    dphi r1.x, r0, model_view_mtx[0]
    dphi r1.y, r0, model_view_mtx[1]
    dphi r1.z, r0, model_view_mtx[2]
    dphi r1.w, r0, model_view_mtx[3]
game_projection:
    ; r0 = game_projection_mtx * inpos
    dp4 r0.x, game_projection_mtx[0], r1
    dp4 r0.y, game_projection_mtx[1], r1
    dp4 r0.z, game_projection_mtx[2], r1
    dp4 r0.w, game_projection_mtx[3], r1
system_projection:
    ; outpos = projection_mtx * inpos
    dp4 outpos.x, projection_mtx[0], r0
    dp4 outpos.y, projection_mtx[1], r0
    dp4 outpos.z, projection_mtx[2], r0
    dp4 outpos.w, projection_mtx[3], r0
texture:
    ; outtex = intex
    mov outtc0, zeros
    mov outtc1, zeros
color:
    ; copy color, scaling it by 1/255
    mul outclr, color_scale, inclr2

    ; We're finished
    end
.end
